import SwiftUI

private let allSubjects = [
    "Algebra",
    "Geometry",
    "Precalculus",
    "Calculus",
    "Statistics",
    "Linear Algebra",
    "Trigonometry",
    "Differential Equations",
    "Physics",
    "Chemistry",
    "Biology",
    "Computer Science",
    "Economics",
    "Engineering",
    "Accounting",
]

struct StepSubjects: View {
    @Binding var subjects: [String]
    let onNext: () -> Void
    let onBack: () -> Void

    private func toggle(_ subject: String) {
        if let idx = subjects.firstIndex(of: subject) {
            subjects.remove(at: idx)
        } else {
            subjects.append(subject)
        }
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            Text("What subjects do you need help with?")
                .reefHeading()
                .padding(.bottom, 6)
                .fadeUp(index: 0)

            Text("Select at least one. You can always change these later.")
                .reefBody()
                .padding(.bottom, 24)
                .fadeUp(index: 1)

            FlowLayout(spacing: 8) {
                ForEach(allSubjects, id: \.self) { subject in
                    SubjectPill(
                        label: subject,
                        isSelected: subjects.contains(subject)
                    ) {
                        toggle(subject)
                    }
                }
            }
            .padding(.bottom, 28)
            .fadeUp(index: 2)

            OnboardingNavigation(
                backLabel: "Back",
                forwardLabel: "Continue",
                canAdvance: !subjects.isEmpty,
                onBack: onBack,
                onForward: onNext
            )
            .fadeUp(index: 3)
        }
    }
}

// MARK: - Flow Layout (wrapping horizontal layout)

struct FlowLayout: Layout {
    var spacing: CGFloat = 8

    func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {
        let result = arrange(proposal: proposal, subviews: subviews)
        return result.size
    }

    func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {
        let result = arrange(proposal: proposal, subviews: subviews)
        for (index, position) in result.positions.enumerated() {
            subviews[index].place(
                at: CGPoint(x: bounds.minX + position.x, y: bounds.minY + position.y),
                proposal: .unspecified
            )
        }
    }

    private func arrange(proposal: ProposedViewSize, subviews: Subviews) -> (size: CGSize, positions: [CGPoint]) {
        let maxWidth = proposal.width ?? .infinity
        var positions: [CGPoint] = []
        var x: CGFloat = 0
        var y: CGFloat = 0
        var rowHeight: CGFloat = 0
        var totalHeight: CGFloat = 0
        var totalWidth: CGFloat = 0

        for subview in subviews {
            let size = subview.sizeThatFits(.unspecified)
            if x + size.width > maxWidth, x > 0 {
                x = 0
                y += rowHeight + spacing
                rowHeight = 0
            }
            positions.append(CGPoint(x: x, y: y))
            rowHeight = max(rowHeight, size.height)
            x += size.width + spacing
            totalWidth = max(totalWidth, x - spacing)
            totalHeight = y + rowHeight
        }

        return (CGSize(width: totalWidth, height: totalHeight), positions)
    }
}
